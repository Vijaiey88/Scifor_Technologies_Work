# -*- coding: utf-8 -*-
"""problem_solving

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZGwct5jViGRKx8roFKGkDyzo4M115S7F
"""

# 1) What is the difference between list and tuple in Python?

# List are mutable whereas tuples are immutable.
# List are defined with square brackets '[]' and tuples are defined with round brackets '()'

# 2) Explain the concept of PEP 8.

# PEP 8 mainly focusses on improving readabality and consistency of python code.

# 3) What is the purpose of the __init__ method in Python classes?

# __init__ method acts as constructor which initialises the class methods.
# This is a special method that is automatically called when object is created from the class.
# The purpose of __init__ method is to initialize attributes of an object when it is crteated.

# 4) How does inheritance work in Python? Provide an example.

# Inheritance in python works as the child class(derived class) inherits attriburtes and methods from base class(parent class).
class Phone:
    def make_call(self):
        print("Making a call")

class Smartphone(Phone):
    def send_message(self):
        print("Sending a message")

smartphone = Smartphone()
smartphone.make_call()
smartphone.send_message()

# Here Smartphone(child/derived class) inherits methods from Phone(parent/base class).

# 5) Explain the difference between staticmethod and classmethod.

# 6) What is Polymorphism in Python? Give an example.

# Poly - many Morph - many
# Single function/method that takes on different forms.
class Addition:
  def __init__(self, a, b):
    self.a = a
    self.b = b
  def add(self):
    return self.a+self.b
addtion = Addition(4, 5).add()
print(addtion)
concat = Addition('Hello','World').add()
print(concat)

# 7) How do you handle exceptions in Python?

# Exception is a condition that interrupts the normal flow of the program.
# This can be handled by try and except block.
# In try block, it raises an exception
# In excpet block, we can print the error detail or statement to handle the exception.

# 8) Explain the Global Interpreter Lock (GIL) in Python.

# 9) What is a decorator in Python? Provide an example.

# Decorators allows you to wrap a function with another function, typically used for pre-processing and post-processing tasks.
def my_decorator(func):   # decorator function
    def wrapper():
        print("Something is happening before the function is called.")
        func()
        print("Something is happening after the function is called.")
    return wrapper
@my_decorator   # decorator
def say_hello():
    print("Hello!")

say_hello()

# 10) How do you implement encapsulation in Python?

class Car:
    def __init__(self, make, model):
        self.make = make
        self.model = model
    def display_info(self):
        print(f"Car Make: {self.make}, Model: {self.model}")

my_car = Car(make="Renault", model="Logan")
print("Make:", my_car.make)
print("Model:", my_car.model)
my_car.display_info()

# 11) Explain the concept of duck typing.

# 12) What is the difference between append() and extend() methods for lists?

#  append() method used to add single element to the end of the list,if an iterable(list) is added as a single elements at the end not as a individual element.
my_list = [1, 2, 3]
my_list.append([4, 5, 6])
print(my_list)
#  extend() method is used to add individual elements from an iterable (e.g., list, tuple, or string) to the end of the list.
my_list = [1, 2, 3]
my_list.extend([4, 5, 6])
print(my_list)

# 13) How does the with statement work in Python?

# The with statement in Python is used to simplify the management of resources, such as files or network connections,
# by ensuring that certain operations are performed before and after a block of code.
with open("example.txt", "r") as file:
  content = file.read()

# 14) Discuss the use of self in Python classes.

# Self represents ths instance of a class.
# This is used to access attributes and methods of the instance of class.

# 15) Explain the purpose of the __slots__ attribute.

# It is a mechanism for optimizing memory usage and can also provide some performance benefits.

# 16) What is the difference between an instance variable and a class variable?

# 17) How do you implement Encapsulation, Abstraction, Polymorphism?

# Encapsulation
class Car:
    def __init__(self, make, model):
        self.make = make
        self.model = model
    def display_info(self):
        print(f"Car Make: {self.make}, Model: {self.model}")

my_car = Car(make="Renault", model="Logan")
print("Make:", my_car.make)
print("Model:", my_car.model)
my_car.display_info()

# Abstraction
class Shape:
  def area(self):
    pass
  def perimeter(self):
    pass

class Rectangle(Shape):
  def __init__(self, length, breadth):
    self.length = length
    self.breadth = breadth
  def area(self):
    return self.length*self.breadth
  def perimeter(self):
    return 2*(self.length*self.breadth)

class Square(Shape):
  def __init__(self, side):
    self.side = side
  def area(self):
    return self.side**2
  def perimeter(self):
    return 4*self.side

# Polymorphism
class Addition:
  def __init__(self, a, b):
    self.a = a
    self.b = b
  def add(self):
    return self.a+self.b
addtion = Addition(4, 5).add()
print(addtion)
concat = Addition('Hello','World').add()
print(concat)

# 18) How do you Implement single level Inheritance, multiple level inheritance, multi level inheritance, Hybrid Inheritance

# single level Inheritance
class Phone:
    def make_call(self):
        print("Making a call")

class Smartphone(Phone):
    def send_message(self):
        print("Sending a message")

smartphone = Smartphone()
smartphone.make_call()
smartphone.send_message()

# multilevel inheritance

class Vehicle:
    def __init__(self, brand, model):
        self.brand = brand
        self.model = model
    def start_engine(self):
        print(f"The engine is starting.")
    def stop_engine(self):
        print(f"The engine is stopping.")
class Car(Vehicle):
    def drive(self):
        print("The car is now in motion.")
class SportsCar(Car):
    def accelerate(self):
        print("The car is accelerating at high speed.")

my_sports_car = SportsCar(brand="Renault", model="Logan")
my_sports_car.start_engine()
my_sports_car.drive()
my_sports_car.accelerate()
my_sports_car.stop_engine()



# multiple level inheritance
class Engine:
    def start(self):
        print("Engine started")
    def stop(self):
        print("Engine stopped")
class ElectricSystem:
    def charge(self):
        print("Charging electric system")
    def discharge(self):
        print("Discharging electric system")
class Car(Engine, ElectricSystem):
    def __init__(self, make, model):
        # Attributes specific to the Car class
        self.make = make
        self.model = model
    def drive(self):
        print(f"{self.make} {self.model} is now driving")

my_car = Car(make="Renault", model="Logan")
my_car.start()
my_car.charge()
my_car.drive()
my_car.stop()
my_car.discharge()


# Hybrid Inheritance
class Animal:   ## Base class
  def speak(self):
    return 'Animal speaks'
class Dog(Animal):  ## Single level inheritance
  def bark(self):
    return 'Dog barks'
class Robot:
  def beep(self):
    return 'Robot beeps'
class RobotDog(Dog, Robot):   ## Multiple inheritance
  def greet(self):
    return 'RobotDog greets'
class RobotiDog(RobotDog):    ## Multilevel inheritance
  def move(self):
    return 'Robotic Dog is very intelligent'

robo_dog = RobotiDog()
print(robo_dog.speak())
print(robo_dog.bark())
print(robo_dog.beep())
print(robo_dog.greet())
print(robo_dog.move())



